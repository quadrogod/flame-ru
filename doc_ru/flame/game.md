# FlameGame

Класс `FlameGame` реализует `Game`, основанный на `Component`. Он содержит дерево компонентов и вызывает методы `update` и `render` для всех компонентов, добавленных в игру.

Мы называем эту компонентную систему Flame Component System (FCS). В документации FCS ссылается именно на эту систему.

Компоненты можно добавлять в `FlameGame` напрямую через именованный аргумент `children` конструктора или из любого другого места с помощью методов `add`/`addAll`. Однако чаще всего вы захотите добавлять компоненты в `World`. Стандартный мир доступен через `FlameGame.world`, и вы добавляете компоненты туда так же, как и в любой другой компонент.

Простой пример реализации `FlameGame`, который добавляет два компонента — один в `onLoad`, другой напрямую в конструкторе:

```dart
import 'package:flame/components.dart';
import 'package:flame/game.dart';
import 'package:flutter/widgets.dart';

/// Компонент, который отображает спрайт ящика размером 16 x 16.
class MyCrate extends SpriteComponent {
  MyCrate() : super(size: Vector2.all(16));

  @override
  Future<void> onLoad() async {
    sprite = await Sprite.load('crate.png');
  }
}

class MyWorld extends World {
  @override
  Future<void> onLoad() async {
    await add(MyCrate());
  }
}

void main() {
  final myGame = FlameGame(world: MyWorld());
  runApp(
    GameWidget(game: myGame),
  );
}
```

```{note}
Если вы создаёте экземпляр игры в методе build, он будет пересоздаваться каждый раз,
когда Flutter-дерево будет перестраиваться, что обычно происходит чаще, чем нужно.
Чтобы этого избежать, можно либо заранее создать экземпляр игры и использовать его в дереве виджетов,
либо использовать конструктор `GameWidget.controlled`.
```

Чтобы удалить компоненты из `FlameGame`, можно использовать методы `remove` или `removeAll`.
Первый удаляет один компонент, второй — список компонентов. Эти методы доступны для всех `Component`, включая мир.

## Игровой цикл

Модуль `GameLoop` — это простая абстракция игрового цикла. В основе большинства игр лежат два метода:

- Метод `render` получает канвас и отрисовывает текущее состояние игры.
- Метод `update` получает время (в микросекундах) с момента последнего обновления и позволяет перейти к следующему состоянию.

Модуль `GameLoop` используется во всех реализациях `Game` во Flame.

## Изменение размера

Каждый раз при необходимости изменения размера игры, например, при смене ориентации, `FlameGame` вызывает методы `onGameResize` у всех `Component`, а также передаёт эту информацию камере и области просмотра.

Камера `FlameGame.camera` управляет тем, какая точка координатного пространства будет закреплена в видоискателе. По умолчанию [0,0] находится в центре (`Anchor.center`) области просмотра.

## Жизненный цикл

Методы жизненного цикла `FlameGame`, такие как `onLoad`, `render` и т.д., вызываются в следующей последовательности:

```{include} diagrams/flame_game_life_cycle.md
```

Когда `FlameGame` впервые добавляется в `GameWidget`, вызываются по порядку методы `onGameResize`, `onLoad` и `onMount`. Затем `update` и `render` вызываются на каждом тике игры. Если `FlameGame` удаляется из `GameWidget`, вызывается `onRemove`. Если игра добавляется в другой `GameWidget`, последовательность начинается снова с `onGameResize`.

```{note}
Порядок вызова `onGameResize` и `onLoad` отличается от других `Component`.
Это сделано для того, чтобы размеры игровых элементов могли быть рассчитаны до загрузки или генерации ресурсов.
```

Метод `onRemove` можно использовать для очистки дочерних компонентов и кэшированных данных:

```dart
  @override
  void onRemove() {
    // Необязательно, зависит от нужд вашей игры.
    removeAll(children);
    processLifecycleEvents();
    Flame.images.clearCache();
    Flame.assets.clearCache();
    // Другой код, который вы хотите выполнить при удалении игры.
  }
```

```{note}
Очистка дочерних компонентов и ресурсов в `FlameGame` не происходит автоматически,
её нужно явно реализовать в `onRemove`.
```

## Режим отладки

Класс `FlameGame` предоставляет переменную `debugMode`, которая по умолчанию равна `false`.
Её можно установить в `true`, чтобы включить отладочные функции компонентов игры. **Обратите внимание**:
значение этой переменной передаётся компонентам при их добавлении в игру, поэтому изменение `debugMode` во время выполнения не повлияет на уже добавленные компоненты по умолчанию.

Подробнее о `debugMode` можно прочитать в [документации по отладке](other/debug.md).

## Изменение цвета фона

Чтобы изменить цвет фона в `FlameGame`, нужно переопределить метод `backgroundColor()`.

В следующем примере цвет фона полностью прозрачен, чтобы можно было видеть виджеты за `GameWidget`.
По умолчанию используется непрозрачный чёрный цвет.

```dart
class MyGame extends FlameGame {
  @override
  Color backgroundColor() => const Color(0x00000000);
}
```

Имейте в виду, что цвет фона нельзя изменить динамически во время выполнения. Если необходимо, нарисуйте фоновый элемент, который перекрывает весь канвас.

## Миксин SingleGameInstance

Необязательный миксин `SingleGameInstance` можно добавить в игру, если вы создаёте однопользовательскую игру. Это частый сценарий: один `GameWidget` на весь экран и одна игра.

Этот миксин даёт преимущества в производительности в определённых случаях. В частности, метод `onLoad` компонента гарантированно вызывается при добавлении к родителю, даже если родитель ещё не смонтирован. Следовательно, `await parent.add(component)` гарантированно завершает загрузку компонента.

Пример использования:

```dart
class MyGame extends FlameGame with SingleGameInstance {
  // ...
}
```

## Низкоуровневый API Game

```{include} diagrams/low_level_game_api.md
```

Абстрактный класс `Game` — это низкоуровневый API, который можно использовать для полной реализации структуры движка. Например, `Game` не реализует `update` и `render`.

Класс также содержит методы жизненного цикла `onLoad`, `onMount` и `onRemove`, которые вызываются из `GameWidget` (или другого родителя) при загрузке, монтировании или удалении игры.
`onLoad` вызывается только при первом добавлении к родителю, `onMount` (следом за `onLoad`) вызывается каждый раз при добавлении к новому родителю, `onRemove` — при удалении.

```{note}
Класс `Game` даёт больше свободы, но вы теряете встроенные функции Flame.
```

Пример реализации `Game`:

```dart
class MyGameSubClass extends Game {
  @override
  void render(Canvas canvas) {
    // ...
  }

  @override
  void update(double dt) {
    // ...
  }
}

void main() {
  final myGame = MyGameSubClass();
  runApp(
    GameWidget(
      game: myGame,
    )
  );
}
```

## Пауза / Возобновление / Пошаговое выполнение игры

Игру во Flame можно приостановить и возобновить двумя способами:

- Через методы `pauseEngine` и `resumeEngine`.
- Изменяя атрибут `paused`.

При приостановке `Game` игровой цикл (`GameLoop`) останавливается — обновления и отрисовка не происходят до возобновления.

Во время паузы можно пошагово продвигать игру с помощью `stepEngine`.
Это может быть не нужно в финальной версии игры, но полезно при отладке и анализе состояния игры во время разработки.

### Фоновый режим

Игра автоматически приостанавливается при переходе приложения в фоновый режим и возобновляется при возвращении. Это поведение можно отключить, установив `pauseWhenBackgrounded = false`.

```dart
class MyGame extends FlameGame {
  MyGame() {
    pauseWhenBackgrounded = false;
  }
}
```

На текущей стабильной версии Flutter (3.13) этот флаг игнорируется на не-мобильных платформах, включая Web.

## Миксин HasPerformanceTracker

Для оптимизации игры может быть полезно отслеживать, сколько времени занимает обновление и отрисовка каждого кадра. Эти данные помогают выявить «горячие» участки кода или визуальные элементы, замедляющие производительность.

Чтобы получить такие данные, просто добавьте миксин `HasPerformanceTracker` к классу игры:

```dart
class MyGame extends FlameGame with HasPerformanceTracker {
  // доступны геттеры `updateTime` и `renderTime`
}
```
