# Камера и Мир

Пример простой структуры игры:

```text
FlameGame
├── World                       // Мир
│   ├── Player                  // Игрок
│   └── Enemy                   // Враг
└── CameraComponent             // Компонент Камеры
    ├── Viewfinder              // Видоискатель
    │   ├── HudButton           // Кнопка интерфейса (HUD)
    │   └── FpsTextComponent    // Компонент текста FPS
    └── Viewport                // Область просмотра
```

Чтобы понять, как работает `CameraComponent`, представьте, что ваш игровой мир — это сущность, которая существует *где-то* независимо от вашего приложения. Представьте, что ваша игра — это просто окно, через которое вы можете смотреть в этот мир. Что вы можете закрыть это окно в любой момент, а игровой мир все равно останется там. Или, наоборот, вы можете открыть несколько окон, которые все смотрят на один и тот же мир (или разные миры) одновременно.

С таким подходом мы теперь можем понять, как работает `CameraComponent`.

Во-первых, существует класс [`World`](#world), который содержит все компоненты, находящиеся внутри вашего игрового мира. Компонент `World` может быть добавлен куда угодно, например, в корень вашего игрового класса, как это сделано со встроенным `World`.

Затем, есть класс [`CameraComponent`](#cameracomponent), который "смотрит" на [`World`](#world). `CameraComponent` содержит внутри себя [`Viewport`](#viewport) и [`Viewfinder`](#viewfinder), что обеспечивает гибкость как для рендеринга мира в любом месте экрана, так и для управления местоположением и углом обзора. `CameraComponent` также содержит компонент [`backdrop`](#backdrop), который статически рендерится под миром.

## World

Этот компонент следует использовать для размещения всех остальных компонентов, составляющих ваш игровой мир. Основное свойство класса `World` заключается в том, что он не рендерится традиционными способами — вместо этого он рендерится одним или несколькими [`CameraComponent`](#cameracomponent) для "взгляда" на мир. В классе `FlameGame` по умолчанию есть один `World` с именем `world`, который добавлен и сопряжен с `CameraComponent` по умолчанию с именем `camera`.

Игра может иметь несколько экземпляров `World`, которые могут рендериться либо одновременно, либо в разное время. Например, если у вас есть два мира A и B и одна камера, то переключение цели этой камеры с A на B мгновенно переключит вид на мир B без необходимости отключать (unmount) A, а затем подключать (mount) B.

Как и для большинства `Component`, дочерние элементы могут быть добавлены в `World` с помощью аргумента `children` в его конструкторе или с использованием методов `add` или `addAll`.

Во многих играх вы захотите расширить `World` и создать свою логику внутри него, структура такой игры может выглядеть так:

```dart
void main() {
  // Запускаем виджет игры с экземпляром нашего мира
  runApp(GameWidget(FlameGame(world: MyWorld())));
}

class MyWorld extends World {
  @override
  Future<void> onLoad() async {
    // Загружаем все ассеты, необходимые в этом мире,
    // добавляем компоненты и т.д.
  }
}
```

## CameraComponent

Это компонент, через который рендерится `World`. Несколько камер могут наблюдать за одним и тем же миром одновременно.

В классе `FlameGame` есть `CameraComponent` по умолчанию с именем `camera`, который сопряжен с `world` по умолчанию, так что вам не нужно создавать или добавлять свой собственный `CameraComponent`, если ваша игра в этом не нуждается.

`CameraComponent` содержит два других компонента: [`Viewport`](#viewport) и [`Viewfinder`](#viewfinder), эти компоненты всегда являются дочерними элементами камеры.

Класс `FlameGame` имеет поле `camera` в своем конструкторе, так что вы можете указать, какой тип камеры по умолчанию вы хотите, например, камеру с [фиксированным разрешением](#cameracomponent-with-fixed-resolution):

```dart
void main() {
  runApp(
    GameWidget(
      FlameGame(
        // Используем камеру с фиксированным разрешением
        camera: CameraComponent.withFixedResolution(
          width: 800,
          height: 600,
        ),
        world: MyWorld(), // Наш игровой мир
      ),
    ),
  );
}
```

Также существует статическое свойство `CameraComponent.currentCamera`, которое возвращает объект камеры, выполняющей рендеринг в данный момент. Это необходимо только для определенных продвинутых случаев использования, когда рендеринг компонента зависит от настроек камеры. Например, некоторые компоненты могут решить пропустить рендеринг себя и своих дочерних элементов, если они находятся за пределами области просмотра (`viewport`) камеры.

### CameraComponent с фиксированным разрешением

Этот именованный конструктор позволит вам представить, что устройство пользователя имеет фиксированное разрешение по вашему выбору. Например:

```dart
final camera = CameraComponent.withFixedResolution(
  world: myWorldComponent, // Мир, на который смотрит камера
  width: 800,              // Желаемая ширина
  height: 600,             // Желаемая высота
);
```

Это создаст камеру с `Viewport`, центрированным посередине экрана, занимающим максимально возможное пространство при сохранении соотношения сторон 4:3 (800x600), и отображающим область игрового мира размером 800 x 600.

С "фиксированным разрешением" очень просто работать, но оно будет не полностью использовать доступное пространство экрана пользователя, если только его устройство не имеет то же соотношение сторон, что и выбранные вами размеры.

## Viewport

`Viewport` — это окно, через которое виден `World`. Это окно имеет определенный размер, форму и положение на экране. Доступно несколько видов `Viewport`, и вы всегда можете реализовать свой собственный.

`Viewport` является компонентом, что означает, что вы можете добавлять к нему другие компоненты. Эти дочерние компоненты будут подвержены влиянию положения `Viewport`, но не его маски обрезки (clip mask). Таким образом, если `Viewport` — это "окно" в игровой мир, то его дочерние элементы — это то, что вы можете разместить поверх окна.

Добавление элементов в `Viewport` — это удобный способ реализации компонентов "HUD" (Heads-Up Display - индикаторы на экране).

Доступны следующие `Viewport`:

- `MaxViewport` (по умолчанию) — этот `Viewport` расширяется до максимального размера, допустимого игрой, т.е. он будет равен размеру игрового холста (canvas).
- `FixedResolutionViewport` — сохраняет разрешение и соотношение сторон фиксированными, с черными полосами по бокам, если они не совпадают с соотношением сторон.
- `FixedSizeViewport` — простой прямоугольный `Viewport` с предопределенным размером.
- `FixedAspectRatioViewport` — прямоугольный `Viewport`, который расширяется, чтобы вписаться в игровой холст, но сохраняет свое соотношение сторон.
- `CircularViewport` — `Viewport` в форме круга, фиксированного размера.

Если вы добавите дочерние компоненты к `Viewport`, они появятся как статические элементы HUD перед миром.

## Viewfinder

Эта часть камеры отвечает за знание того, на какое место в базовом игровом мире мы сейчас смотрим. `Viewfinder` также управляет уровнем масштабирования (zoom) и углом поворота вида.

Свойство `anchor` видоискателя позволяет вам указать, какая точка внутри `Viewport` служит "логическим центром" камеры. Например, в играх-сайдскроллерах часто камера сфокусирована на главном персонаже, который отображается не в центре экрана, а ближе к нижнему левому углу. Эта смещенная от центра позиция и будет "логическим центром" камеры, управляемым свойством `anchor` видоискателя.

Если вы добавите дочерние компоненты к `Viewfinder`, они появятся перед миром, но позади `Viewport` и с теми же трансформациями, которые применяются к миру, поэтому эти компоненты не являются статическими.

Вы также можете добавлять поведенческие компоненты (behavioral components) в качестве дочерних к `Viewfinder`, например, [эффекты](effects.md) или другие контроллеры. Если вы, к примеру, добавите `ScaleEffect`, вы сможете добиться плавного масштабирования в вашей игре.

## Backdrop (Задний фон)

Чтобы добавить статические компоненты позади мира, вы можете добавить их к компоненту `backdrop` или заменить сам компонент `backdrop`. Это полезно, например, если вы хотите иметь статический `ParallaxComponent`, который отображается позади мира, содержащего игрока, который может перемещаться.

Пример:

```dart
// Добавить статический фон как дочерний компонент к backdrop
camera.backdrop.add(MyStaticBackground());
```

или

```dart
// Заменить стандартный backdrop своим компонентом
camera.backdrop = MyStaticBackground();
```

## Управление камерой (Camera controls)

Существует несколько способов изменить настройки камеры во время выполнения:

1.  Использовать функции камеры, такие как `follow()`, `moveBy()` и `moveTo()`.
    Под капотом этот подход использует те же эффекты/поведения (effects/behaviors), что и в пункте (2).

2.  Применять эффекты и/или поведения к `Viewfinder` или `Viewport` камеры.
    Эффекты и поведения — это особые виды компонентов, целью которых является изменение некоторого свойства компонента с течением времени.

3.  Сделать это вручную. Вы всегда можете переопределить метод `CameraComponent.update()`
    (или тот же метод в `Viewfinder` или `Viewport`) и внутри него изменять положение или масштаб (`zoom`) видоискателя по своему усмотрению. Этот подход может быть целесообразен в некоторых обстоятельствах, но в целом он не рекомендуется.

`CameraComponent` имеет несколько методов для управления своим поведением:

- `follow()` заставит камеру следовать за указанной целью (`target`).
  Опционально вы можете ограничить максимальную скорость движения камеры или разрешить ей двигаться только по горизонтали/вертикали.

- `stop()` отменит эффект предыдущего вызова (`follow`, `moveBy`, `moveTo`) и остановит камеру в ее текущем положении.

- `moveBy()` можно использовать для перемещения камеры на указанное смещение (`offset`).
  Если камера уже следовала за другим компонентом или двигалась, эти поведения будут автоматически отменены.

- `moveTo()` можно использовать для перемещения камеры в указанную точку на карте мира.
  Если камера уже следовала за другим компонентом или двигалась к другой точке, эти поведения будут автоматически отменены.

- `setBounds()` позволяет добавить ограничения на то, куда камере разрешено перемещаться. Эти ограничения задаются в виде `Shape`, который обычно является прямоугольником (`Rectangle`), но может быть и любой другой формой.

### visibleWorldRect

Камера предоставляет свойство `visibleWorldRect`, которое представляет собой прямоугольник (`Rect`), описывающий область мира, видимую в данный момент через камеру. Эту область можно использовать для того, чтобы не рендерить компоненты, находящиеся вне поля зрения, или реже обновлять объекты, которые находятся далеко от игрока.

`visibleWorldRect` является кэшируемым свойством и автоматически обновляется всякий раз, когда камера перемещается или `Viewport` изменяет свой размер.

### canSee

`CameraComponent` имеет метод `canSee`, который можно использовать для проверки, виден ли компонент с точки зрения камеры.
Это полезно, например, для отсечения (culling) компонентов, которые не находятся в поле зрения.

```dart
// Если компонент не виден камере
if (!camera.canSee(component)) {
   component.removeFromParent(); // Отсекаем (удаляем) компонент
}
```
